var Bt=Object.defineProperty;var Mt=a=>{throw TypeError(a)};var kt=(a,e,i)=>e in a?Bt(a,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):a[e]=i;var b=(a,e,i)=>kt(a,typeof e!="symbol"?e+"":e,i),Tt=(a,e,i)=>e.has(a)||Mt("Cannot "+i);var t=(a,e,i)=>(Tt(a,e,"read from private field"),i?i.call(a):e.get(a)),p=(a,e,i)=>e.has(a)?Mt("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(a):e.set(a,i),c=(a,e,i,s)=>(Tt(a,e,"write to private field"),s?s.call(a,i):e.set(a,i),i),l=(a,e,i)=>(Tt(a,e,"access private method"),i);var St=(a,e,i,s)=>({set _(n){c(a,e,n,i)},get _(){return t(a,e,s)}});import{W as Vt,X as qt,Y as Xt,u as Yt,C as Zt}from"./BF6ulSEz.js";const ot=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,Nt=new Set,Et=typeof process=="object"&&process?process:{},$t=(a,e,i,s)=>{typeof Et.emitWarning=="function"?Et.emitWarning(a,e,i,s):console.error(`[${i}] ${e}: ${a}`)};let Ft=globalThis.AbortController,Ut=globalThis.AbortSignal;var Gt;if(typeof Ft>"u"){Ut=class{constructor(){b(this,"onabort");b(this,"_onabort",[]);b(this,"reason");b(this,"aborted",!1)}addEventListener(s,n){this._onabort.push(n)}},Ft=class{constructor(){b(this,"signal",new Ut);e()}abort(s){var n,h;if(!this.signal.aborted){this.signal.reason=s,this.signal.aborted=!0;for(const r of this.signal._onabort)r(s);(h=(n=this.signal).onabort)==null||h.call(n,s)}}};let a=((Gt=Et.env)==null?void 0:Gt.LRU_CACHE_IGNORE_AC_WARNING)!=="1";const e=()=>{a&&(a=!1,$t("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}const Jt=a=>!Nt.has(a),K=a=>a&&a===Math.floor(a)&&a>0&&isFinite(a),Pt=a=>K(a)?a<=Math.pow(2,8)?Uint8Array:a<=Math.pow(2,16)?Uint16Array:a<=Math.pow(2,32)?Uint32Array:a<=Number.MAX_SAFE_INTEGER?bt:null:null;class bt extends Array{constructor(e){super(e),this.fill(0)}}var at;const st=class st{constructor(e,i){b(this,"heap");b(this,"length");if(!t(st,at))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new i(e),this.length=0}static create(e){const i=Pt(e);if(!i)return[];c(st,at,!0);const s=new st(e,i);return c(st,at,!1),s}push(e){this.heap[this.length++]=e}pop(){return this.heap[--this.length]}};at=new WeakMap,p(st,at,!1);let Ot=st;var It,jt,N,x,$,P,lt,ft,v,H,F,m,g,R,L,C,T,B,E,k,V,M,q,it,W,o,Ct,nt,Y,gt,U,Ht,ht,ct,pt,Q,tt,Rt,yt,At,S,Wt,dt,et,Dt;const xt=class xt{constructor(e){p(this,o);p(this,N);p(this,x);p(this,$);p(this,P);p(this,lt);p(this,ft);b(this,"ttl");b(this,"ttlResolution");b(this,"ttlAutopurge");b(this,"updateAgeOnGet");b(this,"updateAgeOnHas");b(this,"allowStale");b(this,"noDisposeOnSet");b(this,"noUpdateTTL");b(this,"maxEntrySize");b(this,"sizeCalculation");b(this,"noDeleteOnFetchRejection");b(this,"noDeleteOnStaleGet");b(this,"allowStaleOnFetchAbort");b(this,"allowStaleOnFetchRejection");b(this,"ignoreFetchAbort");p(this,v);p(this,H);p(this,F);p(this,m);p(this,g);p(this,R);p(this,L);p(this,C);p(this,T);p(this,B);p(this,E);p(this,k);p(this,V);p(this,M);p(this,q);p(this,it);p(this,W);p(this,nt,()=>{});p(this,Y,()=>{});p(this,gt,()=>{});p(this,U,()=>!1);p(this,ht,e=>{});p(this,ct,(e,i,s)=>{});p(this,pt,(e,i,s,n)=>{if(s||n)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0});b(this,It,"LRUCache");const{max:i=0,ttl:s,ttlResolution:n=1,ttlAutopurge:h,updateAgeOnGet:r,updateAgeOnHas:d,allowStale:f,dispose:w,disposeAfter:G,noDisposeOnSet:_,noUpdateTTL:Z,maxSize:I=0,maxEntrySize:X=0,sizeCalculation:A,fetchMethod:z,memoMethod:u,noDeleteOnFetchRejection:y,noDeleteOnStaleGet:D,allowStaleOnFetchRejection:O,allowStaleOnFetchAbort:j,ignoreFetchAbort:ut}=e;if(i!==0&&!K(i))throw new TypeError("max option must be a nonnegative integer");const J=i?Pt(i):Array;if(!J)throw new Error("invalid max value: "+i);if(c(this,N,i),c(this,x,I),this.maxEntrySize=X||t(this,x),this.sizeCalculation=A,this.sizeCalculation){if(!t(this,x)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(u!==void 0&&typeof u!="function")throw new TypeError("memoMethod must be a function if defined");if(c(this,ft,u),z!==void 0&&typeof z!="function")throw new TypeError("fetchMethod must be a function if specified");if(c(this,lt,z),c(this,it,!!z),c(this,F,new Map),c(this,m,new Array(i).fill(void 0)),c(this,g,new Array(i).fill(void 0)),c(this,R,new J(i)),c(this,L,new J(i)),c(this,C,0),c(this,T,0),c(this,B,Ot.create(i)),c(this,v,0),c(this,H,0),typeof w=="function"&&c(this,$,w),typeof G=="function"?(c(this,P,G),c(this,E,[])):(c(this,P,void 0),c(this,E,void 0)),c(this,q,!!t(this,$)),c(this,W,!!t(this,P)),this.noDisposeOnSet=!!_,this.noUpdateTTL=!!Z,this.noDeleteOnFetchRejection=!!y,this.allowStaleOnFetchRejection=!!O,this.allowStaleOnFetchAbort=!!j,this.ignoreFetchAbort=!!ut,this.maxEntrySize!==0){if(t(this,x)!==0&&!K(t(this,x)))throw new TypeError("maxSize must be a positive integer if specified");if(!K(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");l(this,o,Ht).call(this)}if(this.allowStale=!!f,this.noDeleteOnStaleGet=!!D,this.updateAgeOnGet=!!r,this.updateAgeOnHas=!!d,this.ttlResolution=K(n)||n===0?n:1,this.ttlAutopurge=!!h,this.ttl=s||0,this.ttl){if(!K(this.ttl))throw new TypeError("ttl must be a positive integer if specified");l(this,o,Ct).call(this)}if(t(this,N)===0&&this.ttl===0&&t(this,x)===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!t(this,N)&&!t(this,x)){const _t="LRU_CACHE_UNBOUNDED";Jt(_t)&&(Nt.add(_t),$t("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",_t,xt))}}static unsafeExposeInternals(e){return{starts:t(e,V),ttls:t(e,M),sizes:t(e,k),keyMap:t(e,F),keyList:t(e,m),valList:t(e,g),next:t(e,R),prev:t(e,L),get head(){return t(e,C)},get tail(){return t(e,T)},free:t(e,B),isBackgroundFetch:i=>{var s;return l(s=e,o,S).call(s,i)},backgroundFetch:(i,s,n,h)=>{var r;return l(r=e,o,At).call(r,i,s,n,h)},moveToTail:i=>{var s;return l(s=e,o,dt).call(s,i)},indexes:i=>{var s;return l(s=e,o,Q).call(s,i)},rindexes:i=>{var s;return l(s=e,o,tt).call(s,i)},isStale:i=>{var s;return t(s=e,U).call(s,i)}}}get max(){return t(this,N)}get maxSize(){return t(this,x)}get calculatedSize(){return t(this,H)}get size(){return t(this,v)}get fetchMethod(){return t(this,lt)}get memoMethod(){return t(this,ft)}get dispose(){return t(this,$)}get disposeAfter(){return t(this,P)}getRemainingTTL(e){return t(this,F).has(e)?1/0:0}*entries(){for(const e of l(this,o,Q).call(this))t(this,g)[e]!==void 0&&t(this,m)[e]!==void 0&&!l(this,o,S).call(this,t(this,g)[e])&&(yield[t(this,m)[e],t(this,g)[e]])}*rentries(){for(const e of l(this,o,tt).call(this))t(this,g)[e]!==void 0&&t(this,m)[e]!==void 0&&!l(this,o,S).call(this,t(this,g)[e])&&(yield[t(this,m)[e],t(this,g)[e]])}*keys(){for(const e of l(this,o,Q).call(this)){const i=t(this,m)[e];i!==void 0&&!l(this,o,S).call(this,t(this,g)[e])&&(yield i)}}*rkeys(){for(const e of l(this,o,tt).call(this)){const i=t(this,m)[e];i!==void 0&&!l(this,o,S).call(this,t(this,g)[e])&&(yield i)}}*values(){for(const e of l(this,o,Q).call(this))t(this,g)[e]!==void 0&&!l(this,o,S).call(this,t(this,g)[e])&&(yield t(this,g)[e])}*rvalues(){for(const e of l(this,o,tt).call(this))t(this,g)[e]!==void 0&&!l(this,o,S).call(this,t(this,g)[e])&&(yield t(this,g)[e])}[(jt=Symbol.iterator,It=Symbol.toStringTag,jt)](){return this.entries()}find(e,i={}){for(const s of l(this,o,Q).call(this)){const n=t(this,g)[s],h=l(this,o,S).call(this,n)?n.__staleWhileFetching:n;if(h!==void 0&&e(h,t(this,m)[s],this))return this.get(t(this,m)[s],i)}}forEach(e,i=this){for(const s of l(this,o,Q).call(this)){const n=t(this,g)[s],h=l(this,o,S).call(this,n)?n.__staleWhileFetching:n;h!==void 0&&e.call(i,h,t(this,m)[s],this)}}rforEach(e,i=this){for(const s of l(this,o,tt).call(this)){const n=t(this,g)[s],h=l(this,o,S).call(this,n)?n.__staleWhileFetching:n;h!==void 0&&e.call(i,h,t(this,m)[s],this)}}purgeStale(){let e=!1;for(const i of l(this,o,tt).call(this,{allowStale:!0}))t(this,U).call(this,i)&&(l(this,o,et).call(this,t(this,m)[i],"expire"),e=!0);return e}info(e){const i=t(this,F).get(e);if(i===void 0)return;const s=t(this,g)[i],n=l(this,o,S).call(this,s)?s.__staleWhileFetching:s;if(n===void 0)return;const h={value:n};if(t(this,M)&&t(this,V)){const r=t(this,M)[i],d=t(this,V)[i];if(r&&d){const f=r-(ot.now()-d);h.ttl=f,h.start=Date.now()}}return t(this,k)&&(h.size=t(this,k)[i]),h}dump(){const e=[];for(const i of l(this,o,Q).call(this,{allowStale:!0})){const s=t(this,m)[i],n=t(this,g)[i],h=l(this,o,S).call(this,n)?n.__staleWhileFetching:n;if(h===void 0||s===void 0)continue;const r={value:h};if(t(this,M)&&t(this,V)){r.ttl=t(this,M)[i];const d=ot.now()-t(this,V)[i];r.start=Math.floor(Date.now()-d)}t(this,k)&&(r.size=t(this,k)[i]),e.unshift([s,r])}return e}load(e){this.clear();for(const[i,s]of e){if(s.start){const n=Date.now()-s.start;s.start=ot.now()-n}this.set(i,s.value,s)}}set(e,i,s={}){var Z,I,X,A,z;if(i===void 0)return this.delete(e),this;const{ttl:n=this.ttl,start:h,noDisposeOnSet:r=this.noDisposeOnSet,sizeCalculation:d=this.sizeCalculation,status:f}=s;let{noUpdateTTL:w=this.noUpdateTTL}=s;const G=t(this,pt).call(this,e,i,s.size||0,d);if(this.maxEntrySize&&G>this.maxEntrySize)return f&&(f.set="miss",f.maxEntrySizeExceeded=!0),l(this,o,et).call(this,e,"set"),this;let _=t(this,v)===0?void 0:t(this,F).get(e);if(_===void 0)_=t(this,v)===0?t(this,T):t(this,B).length!==0?t(this,B).pop():t(this,v)===t(this,N)?l(this,o,yt).call(this,!1):t(this,v),t(this,m)[_]=e,t(this,g)[_]=i,t(this,F).set(e,_),t(this,R)[t(this,T)]=_,t(this,L)[_]=t(this,T),c(this,T,_),St(this,v)._++,t(this,ct).call(this,_,G,f),f&&(f.set="add"),w=!1;else{l(this,o,dt).call(this,_);const u=t(this,g)[_];if(i!==u){if(t(this,it)&&l(this,o,S).call(this,u)){u.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:y}=u;y!==void 0&&!r&&(t(this,q)&&((Z=t(this,$))==null||Z.call(this,y,e,"set")),t(this,W)&&((I=t(this,E))==null||I.push([y,e,"set"])))}else r||(t(this,q)&&((X=t(this,$))==null||X.call(this,u,e,"set")),t(this,W)&&((A=t(this,E))==null||A.push([u,e,"set"])));if(t(this,ht).call(this,_),t(this,ct).call(this,_,G,f),t(this,g)[_]=i,f){f.set="replace";const y=u&&l(this,o,S).call(this,u)?u.__staleWhileFetching:u;y!==void 0&&(f.oldValue=y)}}else f&&(f.set="update")}if(n!==0&&!t(this,M)&&l(this,o,Ct).call(this),t(this,M)&&(w||t(this,gt).call(this,_,n,h),f&&t(this,Y).call(this,f,_)),!r&&t(this,W)&&t(this,E)){const u=t(this,E);let y;for(;y=u==null?void 0:u.shift();)(z=t(this,P))==null||z.call(this,...y)}return this}pop(){var e;try{for(;t(this,v);){const i=t(this,g)[t(this,C)];if(l(this,o,yt).call(this,!0),l(this,o,S).call(this,i)){if(i.__staleWhileFetching)return i.__staleWhileFetching}else if(i!==void 0)return i}}finally{if(t(this,W)&&t(this,E)){const i=t(this,E);let s;for(;s=i==null?void 0:i.shift();)(e=t(this,P))==null||e.call(this,...s)}}}has(e,i={}){const{updateAgeOnHas:s=this.updateAgeOnHas,status:n}=i,h=t(this,F).get(e);if(h!==void 0){const r=t(this,g)[h];if(l(this,o,S).call(this,r)&&r.__staleWhileFetching===void 0)return!1;if(t(this,U).call(this,h))n&&(n.has="stale",t(this,Y).call(this,n,h));else return s&&t(this,nt).call(this,h),n&&(n.has="hit",t(this,Y).call(this,n,h)),!0}else n&&(n.has="miss");return!1}peek(e,i={}){const{allowStale:s=this.allowStale}=i,n=t(this,F).get(e);if(n===void 0||!s&&t(this,U).call(this,n))return;const h=t(this,g)[n];return l(this,o,S).call(this,h)?h.__staleWhileFetching:h}async fetch(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:n=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:d=this.noDisposeOnSet,size:f=0,sizeCalculation:w=this.sizeCalculation,noUpdateTTL:G=this.noUpdateTTL,noDeleteOnFetchRejection:_=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:Z=this.allowStaleOnFetchRejection,ignoreFetchAbort:I=this.ignoreFetchAbort,allowStaleOnFetchAbort:X=this.allowStaleOnFetchAbort,context:A,forceRefresh:z=!1,status:u,signal:y}=i;if(!t(this,it))return u&&(u.fetch="get"),this.get(e,{allowStale:s,updateAgeOnGet:n,noDeleteOnStaleGet:h,status:u});const D={allowStale:s,updateAgeOnGet:n,noDeleteOnStaleGet:h,ttl:r,noDisposeOnSet:d,size:f,sizeCalculation:w,noUpdateTTL:G,noDeleteOnFetchRejection:_,allowStaleOnFetchRejection:Z,allowStaleOnFetchAbort:X,ignoreFetchAbort:I,status:u,signal:y};let O=t(this,F).get(e);if(O===void 0){u&&(u.fetch="miss");const j=l(this,o,At).call(this,e,O,D,A);return j.__returned=j}else{const j=t(this,g)[O];if(l(this,o,S).call(this,j)){const Lt=s&&j.__staleWhileFetching!==void 0;return u&&(u.fetch="inflight",Lt&&(u.returnedStale=!0)),Lt?j.__staleWhileFetching:j.__returned=j}const ut=t(this,U).call(this,O);if(!z&&!ut)return u&&(u.fetch="hit"),l(this,o,dt).call(this,O),n&&t(this,nt).call(this,O),u&&t(this,Y).call(this,u,O),j;const J=l(this,o,At).call(this,e,O,D,A),vt=J.__staleWhileFetching!==void 0&&s;return u&&(u.fetch=ut?"stale":"refresh",vt&&ut&&(u.returnedStale=!0)),vt?J.__staleWhileFetching:J.__returned=J}}async forceFetch(e,i={}){const s=await this.fetch(e,i);if(s===void 0)throw new Error("fetch() returned undefined");return s}memo(e,i={}){const s=t(this,ft);if(!s)throw new Error("no memoMethod provided to constructor");const{context:n,forceRefresh:h,...r}=i,d=this.get(e,r);if(!h&&d!==void 0)return d;const f=s(e,d,{options:r,context:n});return this.set(e,f,r),f}get(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:n=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,status:r}=i,d=t(this,F).get(e);if(d!==void 0){const f=t(this,g)[d],w=l(this,o,S).call(this,f);return r&&t(this,Y).call(this,r,d),t(this,U).call(this,d)?(r&&(r.get="stale"),w?(r&&s&&f.__staleWhileFetching!==void 0&&(r.returnedStale=!0),s?f.__staleWhileFetching:void 0):(h||l(this,o,et).call(this,e,"expire"),r&&s&&(r.returnedStale=!0),s?f:void 0)):(r&&(r.get="hit"),w?f.__staleWhileFetching:(l(this,o,dt).call(this,d),n&&t(this,nt).call(this,d),f))}else r&&(r.get="miss")}delete(e){return l(this,o,et).call(this,e,"delete")}clear(){return l(this,o,Dt).call(this,"delete")}};N=new WeakMap,x=new WeakMap,$=new WeakMap,P=new WeakMap,lt=new WeakMap,ft=new WeakMap,v=new WeakMap,H=new WeakMap,F=new WeakMap,m=new WeakMap,g=new WeakMap,R=new WeakMap,L=new WeakMap,C=new WeakMap,T=new WeakMap,B=new WeakMap,E=new WeakMap,k=new WeakMap,V=new WeakMap,M=new WeakMap,q=new WeakMap,it=new WeakMap,W=new WeakMap,o=new WeakSet,Ct=function(){const e=new bt(t(this,N)),i=new bt(t(this,N));c(this,M,e),c(this,V,i),c(this,gt,(h,r,d=ot.now())=>{if(i[h]=r!==0?d:0,e[h]=r,r!==0&&this.ttlAutopurge){const f=setTimeout(()=>{t(this,U).call(this,h)&&l(this,o,et).call(this,t(this,m)[h],"expire")},r+1);f.unref&&f.unref()}}),c(this,nt,h=>{i[h]=e[h]!==0?ot.now():0}),c(this,Y,(h,r)=>{if(e[r]){const d=e[r],f=i[r];if(!d||!f)return;h.ttl=d,h.start=f,h.now=s||n();const w=h.now-f;h.remainingTTL=d-w}});let s=0;const n=()=>{const h=ot.now();if(this.ttlResolution>0){s=h;const r=setTimeout(()=>s=0,this.ttlResolution);r.unref&&r.unref()}return h};this.getRemainingTTL=h=>{const r=t(this,F).get(h);if(r===void 0)return 0;const d=e[r],f=i[r];if(!d||!f)return 1/0;const w=(s||n())-f;return d-w},c(this,U,h=>{const r=i[h],d=e[h];return!!d&&!!r&&(s||n())-r>d})},nt=new WeakMap,Y=new WeakMap,gt=new WeakMap,U=new WeakMap,Ht=function(){const e=new bt(t(this,N));c(this,H,0),c(this,k,e),c(this,ht,i=>{c(this,H,t(this,H)-e[i]),e[i]=0}),c(this,pt,(i,s,n,h)=>{if(l(this,o,S).call(this,s))return 0;if(!K(n))if(h){if(typeof h!="function")throw new TypeError("sizeCalculation must be a function");if(n=h(s,i),!K(n))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return n}),c(this,ct,(i,s,n)=>{if(e[i]=s,t(this,x)){const h=t(this,x)-e[i];for(;t(this,H)>h;)l(this,o,yt).call(this,!0)}c(this,H,t(this,H)+e[i]),n&&(n.entrySize=s,n.totalCalculatedSize=t(this,H))})},ht=new WeakMap,ct=new WeakMap,pt=new WeakMap,Q=function*({allowStale:e=this.allowStale}={}){if(t(this,v))for(let i=t(this,T);!(!l(this,o,Rt).call(this,i)||((e||!t(this,U).call(this,i))&&(yield i),i===t(this,C)));)i=t(this,L)[i]},tt=function*({allowStale:e=this.allowStale}={}){if(t(this,v))for(let i=t(this,C);!(!l(this,o,Rt).call(this,i)||((e||!t(this,U).call(this,i))&&(yield i),i===t(this,T)));)i=t(this,R)[i]},Rt=function(e){return e!==void 0&&t(this,F).get(t(this,m)[e])===e},yt=function(e){var h,r;const i=t(this,C),s=t(this,m)[i],n=t(this,g)[i];return t(this,it)&&l(this,o,S).call(this,n)?n.__abortController.abort(new Error("evicted")):(t(this,q)||t(this,W))&&(t(this,q)&&((h=t(this,$))==null||h.call(this,n,s,"evict")),t(this,W)&&((r=t(this,E))==null||r.push([n,s,"evict"]))),t(this,ht).call(this,i),e&&(t(this,m)[i]=void 0,t(this,g)[i]=void 0,t(this,B).push(i)),t(this,v)===1?(c(this,C,c(this,T,0)),t(this,B).length=0):c(this,C,t(this,R)[i]),t(this,F).delete(s),St(this,v)._--,i},At=function(e,i,s,n){const h=i===void 0?void 0:t(this,g)[i];if(l(this,o,S).call(this,h))return h;const r=new Ft,{signal:d}=s;d==null||d.addEventListener("abort",()=>r.abort(d.reason),{signal:r.signal});const f={signal:r.signal,options:s,context:n},w=(A,z=!1)=>{const{aborted:u}=r.signal,y=s.ignoreFetchAbort&&A!==void 0;if(s.status&&(u&&!z?(s.status.fetchAborted=!0,s.status.fetchError=r.signal.reason,y&&(s.status.fetchAbortIgnored=!0)):s.status.fetchResolved=!0),u&&!y&&!z)return _(r.signal.reason);const D=I;return t(this,g)[i]===I&&(A===void 0?D.__staleWhileFetching?t(this,g)[i]=D.__staleWhileFetching:l(this,o,et).call(this,e,"fetch"):(s.status&&(s.status.fetchUpdated=!0),this.set(e,A,f.options))),A},G=A=>(s.status&&(s.status.fetchRejected=!0,s.status.fetchError=A),_(A)),_=A=>{const{aborted:z}=r.signal,u=z&&s.allowStaleOnFetchAbort,y=u||s.allowStaleOnFetchRejection,D=y||s.noDeleteOnFetchRejection,O=I;if(t(this,g)[i]===I&&(!D||O.__staleWhileFetching===void 0?l(this,o,et).call(this,e,"fetch"):u||(t(this,g)[i]=O.__staleWhileFetching)),y)return s.status&&O.__staleWhileFetching!==void 0&&(s.status.returnedStale=!0),O.__staleWhileFetching;if(O.__returned===O)throw A},Z=(A,z)=>{var y;const u=(y=t(this,lt))==null?void 0:y.call(this,e,h,f);u&&u instanceof Promise&&u.then(D=>A(D===void 0?void 0:D),z),r.signal.addEventListener("abort",()=>{(!s.ignoreFetchAbort||s.allowStaleOnFetchAbort)&&(A(void 0),s.allowStaleOnFetchAbort&&(A=D=>w(D,!0)))})};s.status&&(s.status.fetchDispatched=!0);const I=new Promise(Z).then(w,G),X=Object.assign(I,{__abortController:r,__staleWhileFetching:h,__returned:void 0});return i===void 0?(this.set(e,X,{...f.options,status:void 0}),i=t(this,F).get(e)):t(this,g)[i]=X,X},S=function(e){if(!t(this,it))return!1;const i=e;return!!i&&i instanceof Promise&&i.hasOwnProperty("__staleWhileFetching")&&i.__abortController instanceof Ft},Wt=function(e,i){t(this,L)[i]=e,t(this,R)[e]=i},dt=function(e){e!==t(this,T)&&(e===t(this,C)?c(this,C,t(this,R)[e]):l(this,o,Wt).call(this,t(this,L)[e],t(this,R)[e]),l(this,o,Wt).call(this,t(this,T),e),c(this,T,e))},et=function(e,i){var n,h,r,d;let s=!1;if(t(this,v)!==0){const f=t(this,F).get(e);if(f!==void 0)if(s=!0,t(this,v)===1)l(this,o,Dt).call(this,i);else{t(this,ht).call(this,f);const w=t(this,g)[f];if(l(this,o,S).call(this,w)?w.__abortController.abort(new Error("deleted")):(t(this,q)||t(this,W))&&(t(this,q)&&((n=t(this,$))==null||n.call(this,w,e,i)),t(this,W)&&((h=t(this,E))==null||h.push([w,e,i]))),t(this,F).delete(e),t(this,m)[f]=void 0,t(this,g)[f]=void 0,f===t(this,T))c(this,T,t(this,L)[f]);else if(f===t(this,C))c(this,C,t(this,R)[f]);else{const G=t(this,L)[f];t(this,R)[G]=t(this,R)[f];const _=t(this,R)[f];t(this,L)[_]=t(this,L)[f]}St(this,v)._--,t(this,B).push(f)}}if(t(this,W)&&((r=t(this,E))!=null&&r.length)){const f=t(this,E);let w;for(;w=f==null?void 0:f.shift();)(d=t(this,P))==null||d.call(this,...w)}return s},Dt=function(e){var i,s,n;for(const h of l(this,o,tt).call(this,{allowStale:!0})){const r=t(this,g)[h];if(l(this,o,S).call(this,r))r.__abortController.abort(new Error("deleted"));else{const d=t(this,m)[h];t(this,q)&&((i=t(this,$))==null||i.call(this,r,d,e)),t(this,W)&&((s=t(this,E))==null||s.push([r,d,e]))}}if(t(this,F).clear(),t(this,g).fill(void 0),t(this,m).fill(void 0),t(this,M)&&t(this,V)&&(t(this,M).fill(0),t(this,V).fill(0)),t(this,k)&&t(this,k).fill(0),c(this,C,0),c(this,T,0),t(this,B).length=0,c(this,H,0),c(this,v,0),t(this,W)&&t(this,E)){const h=t(this,E);let r;for(;r=h==null?void 0:h.shift();)(n=t(this,P))==null||n.call(this,...r)}};let zt=xt;const Kt="https://movies-proxy.vercel.app",mt=new zt({max:500,ttl:2e3*60*60});async function Qt(a,e={}){if(e.language==null){const i=Xt().$i18n.locale;e.language=Yt(i)}return await $fetch(a,{baseURL:`${Kt}/tmdb`,params:e})}function rt(a,e={}){const i=Vt([a,e]),s=qt(i,()=>null);return s.value?s.value:(mt.has(i)||mt.set(i,Qt(a,e).then(n=>(s.value=n,n)).catch(n=>{throw mt.delete(i),n})),mt.get(i))}const wt=new Set(["66046","65143","120057","137215","127008","135272","152511","154887","1123136","209609","153496","214997","203552","735902","561996","198004","206239","210107","234282","203164","219651","599333","919207","606906","231268","119773","223890","229955"]);async function ne(a,e,i){const s=await rt(`${a}/${e}`,{page:i});return s.results=s.results.filter(n=>!wt.has(n.id.toString())),s}async function he(a,e){if(wt.has(e.toString()))throw Zt({statusCode:404,message:"This media is under copyright restriction and cannot be viewed."});return rt(`${a}/${e}`,{append_to_response:"videos,credits,images,external_ids,release_dates,combined_credits",include_image_language:"en"})}async function re(a,e,i=1){const s=await rt(`${a}/${e}/recommendations`,{page:i});return s.results=s.results.filter(n=>!wt.has(n.id.toString())),s}async function oe(a,e,i=1){const s=await rt(`discover/${a}`,{with_genres:e,page:i});return s.results=s.results.filter(n=>!wt.has(n.id.toString())),s}function ae(a){return rt(`genre/${a}/list`).then(e=>e.genres)}function le(a){return rt(`person/${a}`,{append_to_response:"images,combined_credits,external_ids",include_image_language:"en"})}async function fe(a,e=1){const i=await rt("search/multi",{query:a,page:e,include_adult:!1});return i.results=i.results.filter(s=>!wt.has(s.id.toString())),i}export{re as a,ae as b,oe as c,le as d,he as g,ne as l,fe as s};
